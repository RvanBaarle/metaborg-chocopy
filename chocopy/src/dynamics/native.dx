module dynamics/native

imports
  dynamics/stdlib

rules
  builtins :: () -> Pluggable
  builtins() = @
  typedef {
    object = {$type: string, value: any, __init__: function<function<object>, function<object>>}
  } in
  #struct-new<object>() => $NONE;
  #struct-write($NONE, !$type, "None") => _;
  #array-new() => $emptylistcontents;
  #struct-new<object>() => $emptylist;
  #struct-write($emptylist, !$type, "List") => _;
  #struct-write($emptylist, !value, $emptylistcontents) => _;
  fix {
    fun $err_oob() =
      #print("Index out of bounds") => tmp0;
      #print("Exited with error code 3") => tmp1;
      #exit()
    fun $err_div0() =
      #print("Division by zero") => tmp0;
      #print("Exited with error code 2") => tmp1;
      #exit()
    fun $err_invalidarg() =
      #print("Invalid argument") => tmp0;
      #print("Exited with error code 1") => tmp1;
      #exit()
    fun $err_unhandledexn<object>(a) =
      #print("Unhandled exception") => tmp0;
      #exit()
  
    fun $fn_print<object, function<object>, function<object>>(v, c, _) =
      #struct-read(v, !$type) => type;
      if #str-eq(type, "None") then
        $err_invalidarg()
      else
        if #str-eq(type, "int") then
          #struct-read(v, !value) => intv;
          #print<int>(intv) => tmp0;
          c($NONE)
        else
          if #str-eq(type, "str") then
            #struct-read(v, !value) => strv;
            #print<string>(strv) => tmp0;
            c($NONE)
          else
            if #str-eq(type, "bool") then
              #struct-read(v, !value) => boolv;
              if #int-eq(boolv, 1) then
                #print("True") => tmp0;
                c($NONE)
              else
                #print("False") => tmp0;
                c($NONE)
            else
              $err_invalidarg()
    fun $mod(a, b, after) =
      #int-div(a, b) => full_parts;
      #int-mul(full_parts, b) => full;
      #int-sub(a, full) => mod;
      after(mod)
    fun $assert_not_none<object, function<>>(val, after) =
      #struct-read(val, !$type) => ty;
      if #str-eq(ty, "None") then
        #print("Operation on None") => tmp0;
        #print("Exited with error code 4") => tmp1;
        #exit()
      else
        after()
    fun $assert_within_bounds(len, idx, after) =
      if #int-lt(idx, 0) then
        $err_oob()
      else
        if #int-geq(idx, len) then
          $err_oob()
        else
          after()
    fun $fn_len<object, function<int>, function<object>>(val, after, _) =
      #struct-read(val, !$type) => ty;
      if #str-eq(ty, "List") then
        #struct-read<array<any>>(val, !value) => arval;
        #array-length(arval) => len;
        after(len)
      else
        if #str-eq(ty, "str") then
          #struct-read<string>(val, !value) => strval;
          #str-length(strval) => len;
          after(len)
        else
          $err_invalidarg()
    fun $object__init__<function<object>, function<object>>(cont, _) = cont($NONE)
    fun $initialize_object<object, function<>>(self, cont) = 
      #struct-write(self, !__init__, $object__init__) => tmp0;
      cont()
  } in hole
  
  classConstructors :: () -> Pluggable
  classConstructors() = @fix {
    fun $fn_int(after, _) = after(0)
    fun $fn_bool(after, _) = after(0)
    fun $fn_str(after, _) = after("")
    fun $fn_object<function<object>, function<object>>(after, exn) =
      #struct-new<object>( ) => y10;
      #struct-write(y10, !$type, "object") => _;
      fix {
        fun cont() =
          after(y10)
      } in
        $initialize_object(y10, cont)
  } in hole
  
  none :: () -> @cval
  none() = var('"$NONE")
  
  assertNotNone :: @cval -> Pluggable
//  assertNotNone(v) = {
//    var('"$assert_not_none")@([v, after])
//  } label after/0:
  assertNotNone(v) = hole  // TODO: bring back None
  
  assertArrayWithinBounds :: @cval * @cval -> Pluggable
  assertArrayWithinBounds(arr, idx) = {
    len <- #array-length(arr)
    var('"$assert_within_bounds")@([len, idx, after])
  } label after/0:
  
  assertStringWithinBounds :: @cval * @cval -> Pluggable
  assertStringWithinBounds(s, idx) = {
    len <- #str-length(s)
    var('"$assert_within_bounds")@([len, idx, after])
  } label after/0:
  
  assertDivNotZero :: @cval -> Pluggable
  assertDivNotZero(v) = {
    if #int-eq(v, int('0)) then {
      var('"$err_div0")@([])
    } else {
      after@([])
    }
  } label after/0:
  
  mod :: @cval * @cval -> Pluggable(@cval)
  mod(a, b) = {
    var('"$mod")@([a, b, after])
  } label after/1:
  
rules
  boxInt :: @cval -> Pluggable(@cval)
  boxInt(v) = {
    struct <- #struct-new<typevar('"object")>()
    #struct-write(struct, symbol('"$type"), str('"int"))
    #struct-write(struct, symbol('"value"), v)
    struct
  }
  
  boxString :: @cval -> Pluggable(@cval)
  boxString(v) = {
    struct <- #struct-new<typevar('"object")>()
    #struct-write(struct, symbol('"$type"), str('"str"))
    #struct-write(struct, symbol('"value"), v)
    struct
  }
  
  boxBool :: @cval -> Pluggable(@cval)
  boxBool(v) = {
    struct <- #struct-new<typevar('"object")>()
    #struct-write(struct, symbol('"$type"), str('"bool"))
    #struct-write(struct, symbol('"value"), v)
    struct
  }
  
  boxAny :: @cval -> Pluggable(@cval)
  boxAny(v) = {
    struct <- #struct-new<typevar('"object")>()
    #struct-write(struct, symbol('"$type"), str('"object"))
    #struct-write(struct, symbol('"value"), v)
    struct
  }
